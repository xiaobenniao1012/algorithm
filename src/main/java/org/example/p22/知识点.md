参考：https://blog.csdn.net/weixin_53493511/article/details/128605790
题目一【9】
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
注：这是一个dp问题（动态规划问题）

解法：
可以利用动态规划的方式实现，具体做法如下：
定义一个数组 dp，其中 dp[i] 表示以字符 s[i] 为结尾的最长有效括号的长度。
初始化 dp 数组为 0。
当 s[i] 为 '(' 时，dp[i] 必定为 0，因为不可能以 '(' 结尾。
当 s[i] 为 ')' 时，需要分类讨论：
    a. 如果 s[i-1] 是 '('，那么 dp[i] = dp[i-2] + 2。（上一个位置和当前位置正好组成一个有效的括号，所以+2）
    b. 如果 s[i-1] 是 ')'，那么如果 s[i-dp[i-1]-1] 是 '('，那么 dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2。
其中 dp[i-1] 表示以 s[i-1] 结尾的最长有效括号长度，dp[i-dp[i-1]-2] 表示 s[i-1] 之前的最长有效括号长度。
最终 dp 数组中的最大值即为所求。

题目二【26.50】
请编写一个程序，对一个栈里的整型数据，按升序进行排序（即排序前，栈里的数据是无序的，排序后最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。

思路：
利用辅助栈的进出实现将辅助栈从小到大排序（栈顶最小）；
当放入一个元素时，先判断是否能够放入，若不能放入，则将辅助栈的元素弹出到原始栈。

题目三【30.40】
将给定的数转换为字符串，原则如下：1对应 a，2对应b，……26对应z，例如12258可以转换为"abbeh", “aveh”, “abyh”, “lbeh” and “lyh”，个数为5，
编写一个函数，给出可以转换的不同字符串的个数。

解法一：递归
假设求解函数为f(x)，x表示当前位置；g(x)为当前字符转换成那个数值；
若当前位置为字符串的i位置，则i和i之后的字符串转换方式有2种
1）g(i)+ f(i+1)
2）g(i+1)+f(i+2)
最终的结果为2者的和

解法二：动态规划
可以使用动态规划来解决。我们可以使用 dp[i] 表示前i个数字所能转换的不同字符串的个数。
当 i = 0 时，dp[0] = 1；当 i = 1 时，如果 s[0] == '0'，则 dp[1] = 0，否则 dp[1] = 1。当 i > 1 时，设当前数字为 num，前一个数字为 prenum，则有以下两种情况：
如果 num == 0，则只能将 prenum 和 num 组合成 10 或 20，即 dp[i] = dp[i-2]；
如果 num != 0，则可以将 prenum 和 num 组合成一个字母，即 dp[i] = dp[i-1]。如果 prenum 和 num 组合成一个字母超过了 26，则不能组合，即 dp[i] += dp[i-2]。
最后返回 dp[n] 即可。

题目四【50.15】
二叉树每个结点都有一个int型权值，给定一棵二叉树，要求计算出从根结点到叶结点的所有路径中，权值和最大的值为多少。
注：所有二叉树路径的求解都可以使用递归处理。

解法一：递归方式1
从根节点开始遍历，遍历所有节点，遍历过程中将其父节点的权值和作为参数传入，
若当前节点为叶节点，则更新整颗树其权值和，获取最大值。
若当前节点不为叶子节点，则继续向下遍历。

解法二：递归方式2
定义一个方法，该方法获取以当前节点为根节点的最大权值和。因此，在遍历过程中
若当前节点不是叶节点，则获取其左孩子为根节点的最大权值和，同时获取其右孩子为根节点的最大权值和，取其中最大者。
若当前节点为叶节点，则返回其value。

题目五【1.01.23】
给定一个元素为非负整数的二维数组matrix，每行和每列都是从小到大有序的。再给定一个非负整数aim，请判断aim是否在matrix中。

解法：
从右上角开始查找，判断当前值是否大于给定值，
若大于，则向左移动
若小于，则向下移动
若等于，则返回
直到遍历到边界位置处，如果没有找到则返回0