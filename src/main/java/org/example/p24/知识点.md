题目一【1.53】
实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素 的操作。 
要求：1.pop、push、getMin操作的时间复杂度都是O(1)；
2.设计的栈类型可以使用现成的栈结构。

解法：
使用两个栈，一个栈用来存放数据，另一个栈用来存放当前栈中的最小值。
入栈时，如果当前入栈的值比最小值栈的栈顶元素小，则将该值压入最小值栈，否则将最小值栈的栈顶元素再次压入最小值栈。
出栈时，如果当前出栈的值等于最小值栈的栈顶元素，则将最小值栈的栈顶元素弹出，否则不做任何操作。
获取最小值时，直接返回最小值栈的栈顶元素即可。
注：最小值栈中的元素个数与数据栈中的元素个数相同，且最小值栈中的每个元素都是当前数据栈中的最小值。

题目二【6.36】
1）如何仅用栈结构实现队列结构?

解法：
使用两个栈，一个栈用来存放数据，另一个栈用来存放数据的逆序。
入队时，直接将数据压入数据栈。
出队时，如果逆序栈为空，则将数据栈中的数据依次弹出并压入逆序栈，然后将逆序栈的栈顶元素弹出即可。
获取队头元素时，如果逆序栈为空，则将数据栈中的数据依次弹出并压入逆序栈，然后返回逆序栈的栈顶元素即可。
注：数据栈如果将输入放入逆序栈时，要一次性将数据栈中的数据全部放入逆序栈中，否则会出现数据不完整的情况。
注2：逆序栈中的数据如果没有弹出完，则不要将数据栈中的数据放入逆序栈中，否则会出现数据顺序不正确的情况。

题目三【6.36】
如果使用队列结构实现栈结构？

解法：
使用两个队列，一个队列用来存放数据，另一个队列用来存放数据的逆序。
入栈时，如果逆序队列为空，则直接将数据压入数据队列，否则将逆序队列中的数据依次弹出并压入数据队列，然后将数据压入数据队列即可。或者，出栈后将数据栈与逆序栈交换。
出栈时，将数据队列中的数据依次弹出并压入逆序队列，然后将数据队列的队尾元素弹出即可。
获取栈顶元素时，将数据队列中的数据依次弹出并压入逆序队列，然后返回逆序队列的队尾元素即可。

题目四【15.28】 
给你一个二维数组matrix，其中每个数都是正数，要求从左上角走到右下角。每一步只能向右或者向下，沿途经过的数字要累加起来。最后请返回最小的路径和。

解法：
使用动态规划，建立一个二维数组dp，其中dp[i][j]表示从左上角走到(i, j)位置处的最小路径和
最后返回右下角的值即可。

补充：动态规划的空间压缩技巧
如果一个动态规划二维数组，
1）其中某一位的值跟前其上方或左侧的值有关，那么可以考虑使用一维数组来代替二维数组，从而节省空间。从左到右依次计算每一行的值，然后再计算下一行的值。
2）其中某一位的值与其右边和上边相关，则可以从右边开始更新。
3）其中某一位的值与若跨行相关，则可以建立多个一维矩阵。

题目五【38.40】
给定一个数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器， 请返回容器能装多少水
比如，arr = {3，1，2，5，2，4}，根据值画出的直方图就是容器形状，该容器可以装下5格水
再比如，arr = {4，5，1，3，2}，该容器可以装下2格水
注：数组arr组成立方体，其中的凹槽可以用来装水，因此，第一个例子中能装下5格水。 3-5之间的凹槽可以装下3格水，5-4之间的凹槽可以装下2格水，因此，总共可以装下5格水。

解法：
使用两个指针left和right，分别指向数组的第一个元素和最后一个元素。
如果arr[left] < arr[right]，则从左到右遍历数组，如果arr[left] > leftMax，则更新leftMax的值，否则将leftMax - arr[left]的值累加到结果中，然后将left指针右移一位。
如果arr[left] >= arr[right]，则从右到左遍历数组，如果arr[right] > rightMax，则更新rightMax的值，否则将rightMax - arr[right]的值累加到结果中，然后将right指针左移一位。
直到left和right指针相遇为止。

注：某个位置上的水的高度等于该位置左边的最大值和右边的最大值中的较小值减去该位置的值。
即：max{min(leftMax, rightMax) - arr[i],0}，这里的0是因为如果该位置的值大于左右两边的最大值，则该位置上不会有水。
注2：如果左侧leftMax的值大于右侧rightMax的值，则从右到左遍历数组，否则从左到右遍历数组。即，从小的一侧开始遍历数组。