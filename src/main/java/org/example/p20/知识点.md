题目一：[03]
给定一个有序数组arr，代表数轴上从左到右有n个点arr[0]、arr[1]...arr[n-1]，给定一个正数L，代表一根长度为L的绳子，求绳子最多能覆盖其中的几个点。
假设：L=5，数组arr=[2,4,8,9,12,17]

解法一：
初始化最多覆盖点数maxCount为0。
对于数组中的每一个点arr[i]，从该点开始向右找到最远能够覆盖的点，即满足arr[j]-arr[i]<=L的最大的j。
计算覆盖的点数count=j-i+1。
如果count大于maxCount，则更新maxCount为count。
返回maxCount。

解法二：
利用滑动窗口，可以只使用一层循环来实现。具体实现方法如下：
初始化左右指针left和right为0。
初始化最多覆盖点数maxCount为0。
当right指针小于数组长度n时，循环执行以下步骤：
    a. 如果right指针指向的点与左端点的距离小于等于L，则右移right指针。
    b. 否则，左移left指针。
    c. 计算当前窗口能够覆盖的点数count=right-left+1。
    d. 如果count大于maxCount，则更新maxCount为count。
返回maxCount。

题目二：（最小公倍数）[17]
小虎去附近的商店买苹果，奸诈的商贩使用了捆绑交易，只提供6个每袋和8个每袋的包装，包装不可拆分。可是小虎现在只想购买恰好n个苹果，小虎想购买尽量少的袋数方便携带。
如果不能购买恰好n个苹果，小虎将不会购买。输入一个整数n，表示小虎想购买的苹果，返回最小使用多少袋子。如果无论如何都不能正好装下，返回-1。
如：n=30，则返回4(3个8袋+1个6袋)

解法一：
首先判断输入的 n 是否小于 6 或等于 7，因为这些数无法用 6 和 8 的包装恰好装满。如果是，直接返回 -1。
假设用尽量多的 8 个苹果的袋子装 n 个苹果，可以使用 n / 8 个袋子，剩余的苹果数量为 n % 8。
如果剩余的苹果数量为 0，说明已经找到了满足条件的解，直接返回使用的袋子数量。
否则，如果剩余的苹果数量可以被 6 整除，说明可以使用更少的 6 个苹果的袋子来装剩余的苹果，返回使用的袋子数量即可。
如果以上两种情况都不满足，说明用尽量多的 8 个苹果的袋子还不能恰好装下 n 个苹果，需要逐渐减少使用 8 个苹果的袋子的数量，同时增加剩余的苹果数量，直到找到满足条件的解或者无解。具体做法是将使用 8 个苹果的袋子的数量减 1，剩余的苹果数量加 8，然后再进行判断。
如果经过多次尝试，还是找不到满足条件的解，说明无解，返回 -1

解法二：（善于总结：针对数学相关算法，是否支持查表法）
通过代码实际运行规律总结出来。
如运行：n=1-100 运行solution_01，查看数据结果，然后归纳总结

题目三：（博弈论）[43]
假设现在有两只动物吃草，每次只能吃4的次幂的草，也就是1、4、16等等，现在，给你一个整数N，代表总共有多少草，两只动物，只能交替吃草，有先手和后手区别，
假设动物都绝顶聪明，哪只动物先吃完草，哪只就赢，请你求出N份草时，是先手赢还是后手赢？
例如：n=6，则先手赢

解法一：
如果当前剩余草量 N 为 0，则表示当前动物无法再吃草，此时另一只动物获胜。
如果当前剩余草量 N 不为 0，则当前动物可以选择吃 1、4、16...中的任意一个数量的草。
如果当前动物选择吃 x 株草，则剩余草量为 N - x，交换角色后，另一只动物需要在剩余草量为 N - x 的情况下继续尝试赢得胜利。
如果另一只动物无法获胜，则表示当前动物可以在这种情况下获胜。

解法二：（查表法）
通过代码实际运行规律总结出来。
如运行：n=1-100 运行solution_01，查看数据结果，然后归纳总结

题目四：[1.10]
牛牛有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。牛牛现在可 以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将 会被覆盖。牛牛的目标是在完成染色之后,每个红色R都比每个绿色G距离最左侧近。 牛牛想知道他最少需要涂染几个正方形。
一行字符串s，由R和G构成，表示正方形的颜色（R为红色，G为绿色）|s|，求一个数最少需要涂染几个正方形。
输入：RGGGR，结果：1 （将最后的R染成G）

解法一：
从前向后遍历，找到一个基准点
统计该基准点前需要染色成R的个数
统计从该点开始（包括该点），及其后需要染成G的个数
2者的和为本次基准需要染色的个数
最后分别考虑2个端点的情况，即i=0和i=n的情况。

解法二：(预处理-缓存记录，减少每次统计数值执行次数)
首先统计出字符串中R的个数和G的个数，然后从左往右依次遍历字符串，分别记录当前位置左边R的个数和右边G的个数，计算出将当前位置染成G需要涂染的正方形数，取所有位置中最小的即为答案。

题目五：[1.30]
给定一个N*N的矩阵matrix，只有0和1两种值，返回边框全是1的最大正方形的边长长度。
例如
01111
01001
01001
01111
01011
其中边框全是1的最大正方形的大小为4*4，所以返回4.

解法一：
选取一个点N（n,m），这个点作为正方形的左上角，可以有多少个正方形，然后看里面的正方形边长都是1的情况。

时间复杂度分析：
矩阵：时间复杂度分析，任意选择一个点（n^2种可能），再取一个点（也是n^2种可能性），2个点可以确定出矩阵的位置，因此时间复杂度为:O(n^4)
正方形：时间复杂度分析，任意选择一个点（n^2种可能），另外一个变量这是变的长度（常数项取值），因此，时间复杂度为：O(n^3)
另外，验证边全是1，也需要进行循环判断，因此可能达到n的级别，整体时间复杂度会达到：O(n^4)

解法二：（预处理简化验证边全是1的辅助结构）
right矩阵：从右到左、再从下到上，生成每个点（包含该点）右侧有几个连续的1
down矩阵：从下到上，从右到左，生成每个点（包含该点）下方有几个连续的1

题目六：【1.55】
1)给定一个函数f，可以1-5的数字等概率返回一个。请加工出一个函数g可以等概率返回1-7的数字。
2)给定一个函数f，可以a-b的数字等概率返回一个。请加工出一个函数g可以等概率返回c-d的数字。(拓展)
注：这里的a、b、c、d都是整数。
思路与1一样，先加工出0或1等概览函数，然后利用二进制位获取{0-(d-c)}范围的数据，在加上一个c值即可。
3)给定一个函数f，以p概率返回0，以1-p概率返回1。请加工出一个函数g可以等概率返回0和1。

解法1：
先实现一个等概率返回0或1的函数，记为：f1（规定f函数返回1或2，则定义为0；返回4或5，则定义为1；返回3，则重新计算f函数）
利用3个二进制位实现1-7的随机函数（1-7只需要3个二进制位即可，因此，计算3次f1函数得到3个二进制位）。
    调用f1函数3次，获得一个数值 int t= (f1()<<2) + (f1()<<1) + f1(); （第一次调用f1函数后左移2位到第3位上，第二次调用f1函数后左移1位到第2位上，第三调用f1函数不在进行移位操作）
    调用3次得到的数值范围为0-7，如果值为0，则重新计算，最终返回一个1-7上等概率函数。

解法3：
p概率返回0，1-p概览返回1；
每次都调用2次，如果获取{0,1}则定义为0；获取{1,0}则定义为1；获取{0,0}或{1,1}则重新调用。
    {0,1}的概率为：p*(1-p);
    {1,0}的概率为：(1-p)*p;
    2者是等概率的。
