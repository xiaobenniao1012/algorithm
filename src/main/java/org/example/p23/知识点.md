题目一【02.03】
有n个打包机器从左到右一字排开，上方有一个自动装置会抓取一批物品到每个打包机上，放到每个机器上的这些物品数量有多有少，由于物品数量不相同，
需要工人将每个机器上的物品进行移动从而到达物品数量相等才能打包。每个物品重量太大、每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动。
请计算在搬动最小轮数的前提下，使每个机器上的物品数量相等。如果不能使每个机器上的物品相同，返回-1。
例如[1,0,5]表示有3个机器，每个机器上分别有1、0、5个物品，经过这些轮后：
第一轮：1 0 <- 5 => 1 1 4
第二轮：1 <-1<- 4 => 2 1 3
第三轮：2 1 <- 3 => 2 2 2
移动了3轮，每个机器上的物品相等，所以返回3
例如[2,2,3]表示有3个机器，每个机器上分别有2、2、3个物品，这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回-1。

解法：
首先，我们需要计算出所有机器上物品的总数 total，如果 total 不能被 n 整除，那么一定不能使每个机器上的物品相同。
否则，我们需要计算出每个机器上需要移动的物品数量，设 target 为每个机器上的物品数量，则 target = total / n。
接着，我们可以遍历每个机器，计算出当前机器需要移动的物品数量 move。
如果 move 不为 0 并且当前机器两侧的机器上的物品数量都少于target，则需要将当前机器上的物品移动到左边或右边的机器上，具体移动哪一侧的机器需要根据距离来判断。
当遍历结束后，如果每个机器上的物品数量不相同，则返回 -1，否则返回移动的轮数。

思路：
定位一个位置，判断该位置的左、右2侧各需要移动多少个物品
如：当前index位置，左侧的总和与左侧需要的数据量相减，求出左侧需要移动多少件（可能抛出，也可能接收）；同样的方式可以计算出右侧需要移动多少件。
计算当前index位置为基准，左右2侧至少要移动的物品次数计算公式：
1）2侧都需要接收，左侧需要a件，右侧需要b件，则结果为:|a|+|b|
2）左侧需要接收a，右侧需要抛出b，则结果为：max{|a|,|b|}
3）左侧需要抛出a，右侧需要接收b，则结果为：max{|a|,|b|}
4）左侧需要抛出a，右侧也需要抛出b，则结果为：max{|a|+|b|}，当前位置可以同时接收
因此，计算出数组中每个index位置需要移动的数量，其中最大的值则为需要移动的轮数。

变种，需要计算出移动次数，这里的移动次数指，从一台机器移动到另一台机器则累计+1；

题目二【26.32】
用螺旋的方式打印矩阵，比如如下的矩阵
0 1  2  3
4 5  6  7
8 9 10 11
打印顺序为：0 1 2 3 7 11 10 9 8 4 5 6

解法：
宏观的方式来处理，定位矩阵的左上角（i,j）和右下角(k,m)。
顺时针打印定位的边框节点；
沿对角线移动左上角位置（i+1，j+1），沿对角线相上移动右下角（k-1,m-1）;
继续顺时针打印定位的边框节点；
直到左上角和右下角的节点位置错过或相遇则停止。

题目三【33.31】
给定一个正方形矩阵，只用有限几个变量，实现矩阵中每个位置的数顺时针转动
90度，比如如下的矩阵
0 1 2 3
4 5 6 7
8 9 10 11
12 13 14 15
矩阵应该被调整为：
12 8 4 0
13 9 5 1
14 10 6 2
15 11 7 3

解法：（思路：剥洋葱和分组）
首先定义四个临时变量tR, tC, dR, dC，来保存矩阵A的对角元素值（左上角和右下角）。
以矩阵左上角点（0,0）和右下角点（n-1,n-1）作为坐标原点，从左上角（0,0）开始，按顺时针方向遍历矩阵，每次处理一个圈（矩阵边框）。
实际的旋转，其实是相关点的值交互，总结出交互规律：
    左上角点赋值给临时变量 ：tmp = m[tR][tC + i];
    左下角点赋值给左上角点 ：m[tR][tC + i] = m[dR - i][tC];
    右下角点赋值给左下角点： m[dR - i][tC] = m[dR][dC - i];
    右上角点赋值给右下角点： m[dR][dC - i] = m[tR + i][dC];
    临时变量赋值给右上角点： m[tR + i][dC] = tmp;
注：矩阵的长度作为分组次数，即上面的i变量的取值范围。
遍历完矩阵中的所有元素后，矩阵A的每个位置的数都旋转了90度。

题目四【52.21】
用zigzag的方式打印矩阵，比如如下的矩阵
0 1 2 3
4 5 6 7
8 9 10 11
打印顺序为：0 1 4 8 5 2 3 6 9 10 7 11
注：即为Z字形打印

解法： （思路：斜线打印）
1）定义2个点A和B，A点为斜线的起点，B点为斜线的终点。 斜线的起点A的坐标为（0,0），斜线的终点B的坐标为（0,0）。
2）定义一个布尔变量，用来控制斜线的打印方向，true表示从A点到B点，false表示从B点到A点。
开始时，A点向右移动，B点向下移动，斜线的打印方向为true。
单方向打印完成后，A点和B点的坐标都会发生变化，A点向右移动，B点向下移动，斜线的打印方向也会发生变化，即布尔变量取反。
在A点向右移动过程中，如果A点到达了最右边的列，则向下移动，否则向右移动。
在B点向下移动过程中，如果B点到达了最下边的行，则向右移动，否则向下移动。
直到A点和B点都到达了矩阵的最右下角，则停止。
注：斜线打印的过程中，A点和B点的坐标始终保持在矩阵的边界上。

题目五【1.05.03】
假设s和m初始化，s = “a”; m = s;
再定义两种操作，第一种操作：
m = s;
s = s + s;
第二种操作：
s = s + m;
求最小的操作步骤数，可以将s拼接到长度等于n

解法：
此题可用贪心思想，argumentation 向对比法来解决。
1)由于s的初始值为“a”，则最小操作数为1。
2)比较s的长度与n的大小，如果s的长度小于n，则采取第一种操作，使s=s+s；否则采取第二种操作,使s=s+m。
3)执行步骤2，直到s的长度等于n，记录当前操作步骤数，取最小值，即为最小操作步骤数。

如：
n=3，即（3*1），若执行第二种操作需要执行2次，同时也可以先执行第一种操作，再执行第二种操作，也是2次
n=4，即(2*2)，若执行第二种操作需要执行3次，同时执行第一种操作2次。
n=5，即（5*1），只能执行第二种操作需要执行4次
n=6，即（3*2），若执行第二种操作需要执行5次；可在n=3的基础上，再执行第一种操作，需要3次。
n=7，即（7*1），只能执行第二种操作需要执行6次
n=8，即（4*2），若执行第二种操作需要执行7次；可在n=4的基础上，再执行第一种操作，需要3次。
n=9，即（3*3），若执行第二种操作需要执行8次；可在n=3的基础上，再执行一次第一种操作，最后执行第二种操作，需要4次
...
待实现...

题目六【1.22.17】
给定一个字符串类型的数组arr，求其中出现次数最多的前K个
注：利用2种结果，词频表和堆

解法：
1）利用哈希表，key为字符串，value为字符串出现的次数。
2）方法一：利用小根堆，堆中存放字符串，按字符串出现的次数排序。同时限制堆的大小为k,堆中的字符串都是出现次数最多的字符串。
3）方法二：利用大根堆，堆中存放字符串，按字符串出现的次数排序。不要限制堆大小，从堆中取出前k个字符串，即为出现次数最多的前k个字符串。
注：小根堆和大根堆的实现，可以利用java中的PriorityQueue类，PriorityQueue默认是小根堆，可以通过传入Comparator接口的实现类，来实现大根堆。
注2：在小根堆上，如果一个元素值小，则排在堆顶，如果被元素挤出去，则也是要从堆顶开始挤出去。

若要实现堆大小限制，需要手动写一个对，默认的PriorityQueue类不支持堆大小限制。
