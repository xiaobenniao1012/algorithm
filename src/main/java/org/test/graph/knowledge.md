图（节点和边）
一、图的存储结构
1、邻接表（邻接链表）、邻接矩阵法
邻接矩阵参考：https://blog.csdn.net/diviner_s/article/details/106978910
注：使用二维数组来记录，节点之间没有边时，使用正无穷大
邻接表参考：https://blog.csdn.net/qq_40609809/article/details/96760864
注：链表的方式记录某个节点能到的节点（连通性）

2、图相关数据结构：视频 P9 00:18:20
Public class Graph{
public Map<Integer,Node> nodes;//节点集合(key表示编号)
public Set<Edge> edges;//边
}
public class Node{
public int value;
public int in;//入度
public int out;//出度
public List<Node> nexts;//从当前节点开始，连接的其他节点
public List<Edge> edges;//边
}
public class Edge{
public int weight;
public Node from;
public Node to;
}



3、实例：邻接矩阵和图结构的相互转换。
4、图的宽度优先遍历
思路：
1）利用队列实现；
2）从源节点开始依次按照宽度进队列，然后弹出；
3）每弹出一个节点，把该节点所有没有进过队列的邻接点放入队列；
4）遍历队列直到队列空。
注：图中会有环的情况，使用set过滤避免出现环的情况。
5、深度优先遍历
1）利用栈来实现 stack
2）从源节点开始把节点按照深度放入栈中，然后弹出
3）每弹出一个节点，如果该节点还有邻接点，则需要把该节点重新放入栈中，再把该节点下一个没有进入过栈的邻接点放入栈中
3）直到栈遍历空
6、拓扑排序算法 P9 1:08:00
实际实例：代码编译时，都会设置相关依赖，依赖会先进行编译，编译完成后才能继续编译，一定不会出现循环编译，否则会出现编译错误。-类似有向图
1）在有向图中，首先找到入度为0的点。
2）将该节点和该节点出去的边移除，再剩余的节点中继续查找入度为0的点。
7、最小生成树
什么是最小生成树，保证节点的联通性，并且所有边的权值累加和是最小的。
1）kruskal算法（无向图）
思路：从最小边开始添加，如果没有形成环则成功，依次加入次小边；最终一定能得到各个节点的连通图。
2）prim算法（无向图）
思路：找一个节点，从该节点出发找到一个改节点最小的出边，并将相应的节点放入栈中；依次查找节点对应的最小边，继续找下去，直到找到所有的节点。
注：若节点的出边都访问过了，则退回到上个节点。
3）如何判断图是否有环？P9 1:27:00
8、dijkstra算法（没有权值为负数的边）-求解最短路径 P9 2:03:00
规定一个出发点，求出该点到其他点的最短距离。
思路：
1）取出起始阶段，初始定义，起始节点到自身距离为0，到其他节点默认为无穷大。
2）取出距离最近的点（遍历数据获取最小的节点），从该点出发获取该点的出边，判断从该点到其他节点与A到该点的和，是否小于A到其他节点的距离，如果小于则替换。
3）不断取出次远距离的点，继续更新A到其他节点的距离。
注：加速方式（P11 00:00:00），使用小根堆，每次可以从堆顶获取最小的节点。遍历节点需要修改堆的节点值，然后从新调整堆成为小根堆。

9、前缀树 P10 00:10:00
典型应用场景是统计、保存大量的字符串，经常被搜索引擎系统用于文本词频统计。它的优点是利用字符串的公共前缀来减少查找时间，最大限度的减少无谓字符串的比较和存储空间。
常见操作：
1）获取前缀文本的数量
2）删除一个文本